#![type_length_limit = "5000000"]

extern crate krill;

use std::path::PathBuf;
use std::str::FromStr;

use krill::commons::api::Handle;
use krill::commons::eventsourcing::{AggregateStore, DiskAggregateStore};
use krill::commons::util::softsigner::OpenSslSigner;
use krill::constants::PUBSERVER_DFLT;
use krill::daemon::ca::CertAuth;
use krill::pubd::Repository;

/// This tests that we can understand all events as they have been implemented since 0.4.0,
/// in order to guarantee that upgrades will work.
///
/// The `test-resources/events` directory contains old event files that we will need to keep
/// supporting in future versions.
///
/// They are typically generated by the functional tests in the `tests` dir, and then copied and
/// preserved here for testing. Because, programmatically generating the json and then parsing
/// would of course not work for this purpose, new code would understand what it generates itself,
/// we want to be sure that new code understands old code json.
///
/// So, for each release of krill that may have introduced new event types and/or ways of serializing
/// them, you will find a directory here with the events that were generated by those tests, and you
/// will find a test that will attempt to create `CertAuth` and `Repository` instances by replaying
/// them.
///
/// Directory lay-out is as follows:
///
/// test-resources/
///   events/
///     0.4.0/
///       ca_keyroll_under_rfc6492_ta/
///          /cas
///             /ta
///             /ca
///                .. CertAuth events for each instance
///          /pubd
///             .. Repository events and snapshot
///       other tests.
///     new versions
#[tokio::test]
async fn upgrades() {
    since_0_4_0("ca_embedded", &["ta", "child"]).await;
    since_0_4_0("ca_grandchildren", &["ta", "CA1", "CA2", "CA3", "CA4"]).await;
    since_0_4_0("ca_keyroll_rfc6492", &["ta", "rfc6492"]).await;
    since_0_4_0("ca_rfc6492", &["ta", "rfc6492"]).await;
    since_0_4_0("ca_roas", &["ta", "child"]).await;
    publication_since_0_4_0().await;
}

async fn since_0_4_0(scenario: &str, cas: &[&str]) {
    let work_dir = PathBuf::from(format!("test-resources/api/regressions/0.4.0/events/{}/", scenario));
    test_cas(&work_dir, cas).await;
    test_repo(&work_dir, "pubd").await;
}

async fn publication_since_0_4_0() {
    let work_dir = PathBuf::from("test-resources/api/regressions/0.4.0/events/remote_publication/");
    test_cas(&work_dir, &["ta", "child"]).await;
    test_repo(&work_dir, "pubd").await;
    test_repo(&work_dir, "remote-pubd").await;
}

async fn test_cas(work_dir: &PathBuf, cas: &[&str]) {
    let ca_store = DiskAggregateStore::<CertAuth<OpenSslSigner>>::new(&work_dir, "cas").unwrap();

    for ca in cas {
        assert_no_snapshot(work_dir, &format!("cas/{}", ca));
        let ca_handle = Handle::from_str(ca).unwrap();
        if let Err(e) = ca_store.get_latest(&ca_handle).await {
            panic!("Could not rebuild state for ca '{}', error: {}", ca, e);
        }
    }
}

async fn test_repo(work_dir: &PathBuf, repo: &str) {
    let repo_store = DiskAggregateStore::<Repository>::new(&work_dir, repo).unwrap();
    assert_no_snapshot(work_dir, &format!("{}/{}", repo, PUBSERVER_DFLT));
    let handle = Handle::from_str(PUBSERVER_DFLT).unwrap();
    if let Err(e) = repo_store.get_latest(&handle).await {
        panic!("Could not rebuild state for repository: {}", e)
    }
}

fn assert_no_snapshot(workdir: &PathBuf, rel: &str) {
    let mut snapshot_file = workdir.clone();
    snapshot_file.push(rel);
    snapshot_file.push("snapshot.json");
    if snapshot_file.exists() {
        panic!(
            "Snapshot file should not exist for this test, remove: {}",
            snapshot_file.to_string_lossy().to_string()
        );
    }
}
